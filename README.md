# RSA-public-key-codes
RSA key generation python codes

提升 RSA 加密系统总体的加速和安全性（算法分析与评议更有效增强型混合和并行模型）

Overall RSA Cryptosystem Speed and Security improvement (Algorithm analysis and evaluation of the Hybrid and Parallel domain enhanced approach)

摘 要
加密涉及使用和学习代码的各个方面。在过去的 40 年里，它已经发展成为一门著名的学术学科。由于现在大多数交互都在线进行，因此人们需要安全的方式来传输敏感信息。一些现代密码系统依赖于公钥作为其体系结构的重要关键组件。这项研究的主要目标是提高算法的速度和安全性。虽然 RSA 密码系统目前非常安全, 但它存在一些问题和挑战。例如, 由于其安全性取决于更大的密钥大小, 这会降低运行速度, 以及未来的量子计算威胁, 这促使我们使用更大的密钥大小,“预防胜于治疗”, 以及如何在几秒钟内选择大素数。RSA 也容易受到一些明文和定时攻击，我们将在提高整体系统性能的同时进行分析这些攻击因为速度绝对是创造力的关键。RSA 大数解密一开始比较困难，速度较慢，但应用 CRT 后速度变得非常快，建议继续使用该定理。本研究在计算 N 使用了另外两个随机标准，以及其他算法，例如 Chi-Square（卡方）检验以确定 LCG 生成的一组给定数字是否随机分布，用于加密的快速求幂算法，更快的乘法算法，以及对因式分解算法的透彻理解。我们自己的技术，例如用于防止明文攻击的成对私钥和公钥和不可加密消息分析，将素数定理命题与 MRLCG 一起应用于更快的素数生成，小指数选择条件件以简化计算，以及基于加密算法的云关键日志存储系统方法为了保护日志所有者在服务器端查找其数据的能力，所有这些都导致了一个普遍优化的 RSA 算法，该算法更加高效和安全。最后, 我们将讨论优化和标准 RSA 算法, 以及因式分解和乘法算法的比较。

#ABSTRACT
Encryption involves every aspect of working with and learning about codes. Over the last 40 years, it has grown in prominence to become a prominent scholarly discipline. Because most interactions now take place online, people require secure means of transmitting sensitive information. Several modern cryptosystems rely on public keys as a crucial component of their architecture. The primary goal of this research is to improve the speed and security of the RSA algorithm considering that although the RSA cryptosystem is currently highly secure, it has some challenges and issues such as its security being dependent on a large key size, which slows runtime speed, and future quantum computing threats that urge us to use larger key sizes,” prevention is better than cure”, and challenges on how to choose large primes in a matter of seconds, RSA is also vulnerable to some plaintext and timing attacks, which we will analyze while improving overall system performance because speed is absolutely key to creativity. RSA large numbers decryption was difficult and slower at first, but by applying CRT, it became extremely fast, and we recommended continuing to use this theorem. 
This study uses two more random standards in the computation of N, as well as other algorithms such as the Chi-Square test to determine whether a given set of numbers generated by LCG is randomly distributed, the Fast Exponentiation Algorithm for encryption, the Faster Multiplication Algorithm, and a thorough understanding of factorization algorithms. Our own techniques, such as paired private and public keys and unencryptable messages analysis for plaintext attack prevention, applied prime number theorem proposition with MRLCG for faster prime generation, small exponent selection conditions for easier computing, and Encryption algorithm-based Cloud Critical Logs Storage System methods that protect the log owner’s ability to seek their data on the server side, all resulted in a generally optimized RSA algorithm that is more efficient and secure. Finally, a comparison of the standard RSA algorithm compared to the optimized RSA algorithm, as well as factorization and multiplication algorithms, will be presented.

9.1 Code Revamping
There is always room for advancement in the field of research. Although the code has been considerably updated and enhanced over the course of this project, there is still plenty more that can be done to make it even more streamlined and automated. It is feasible to create a single piece of software that can manage everything. With this, we can be confident that the LCG, prime sieve, and Rabin Miller algorithms are being implemented correctly in a new specific application that we called MRLCG (MillerRabin LCG). While LCG generates odd numbers not divisible by 2,3,5,7, and other 100 first primes within a given range interval to extract prime candidates from the LCG list, and then later used Miller Rabin for the strong primality test technique.
Following the completion of the software’s run, we will give various graphs and data comparing traditional prime generation procedures to our LCG methodology. Python was chosen for its flexibility and convenience. In conclusion, superior results were obtained since it created numerous primes at once in less time than traditional single prime generator procedures. Since we’ve been using a standard laptop for everything, using a server to test the algorithm would likely be the major benefit to the project. All of our Python codes are available on my GitHub repository (Moise[6]).
